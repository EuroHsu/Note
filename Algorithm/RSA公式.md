# RSA公鑰與私鑰運算之演算過程

## RSA源起

RSA加密演算法是一種非對稱加密演算法，在現代公開密鑰加密系統中被廣泛使用。RSA是1977年由羅納德·李維斯特（Ron Rivest）、阿迪·薩莫爾（Adi Shamir）和倫納德·阿德曼（Leonard Adleman）一起提出的。當時他們三人都在麻省理工學院工作。RSA就是他們三人姓氏開頭字母拼在一起組成的。對極大整數做因數分解的難度決定了RSA演算法的可靠性。換言之，對一極大整數做因數分解愈困難，RSA演算法愈可靠。

## 歐拉函數

RSA運算的核心起源於歐拉函數，歐拉函數的定義是在數論中，對正整數n，小於或等於n的正整數中與n互質的總個數。此函數以其首名研究者歐拉命名，它又稱為φ函數。舉例來說：

	φ(8) = 4; 因為1, 3, 5, 7均和8互質。

在歐拉函數中，有一個特別的狀況，就是如果有兩個整數互為質數時，他們相乘後的積如果恰為n值，那麼可以透過過下列的公式快速的算出互質個數。

	n = p * q;	//令p與q互質
	φ(n) = φ(p*q) = φ(p)*φ(q) = (p-1)*(q-1);

假設我們選定p=11, q=13，並確定p與q互為質數，那麼我們可以套用上面的歐拉函數算出下列的結論。

	n = 11 * 13 = 143;
	φ(143) = φ(11*13) = φ(11)*φ(13) = (11-1)*(13-1) = 120;

這裡會出現一個重要的結論，我們可以發現n是120，化成2進制就是「1111000」，那也就是說這一個密鑰的基礎長度就是7 bits，這只是實驗性的參數，真正要運用的話，請使用1024 bits或2048 bits。

另外請挑選出一個「隨機整數」e，並套用到1 < e < φ(n)，並且挑選到的e與φ(n)必須互質。所以我們挑選e=23，23與120為互質沒錯。

## 模反元素

又稱為同餘式，例如：23 ≡ 2 (mod 3)；這邊純就模反元素應用於RSA演算來討論，也就是：如果有兩個正整數e, n互為「質數」，那麼一定可以找到一個整數d，讓ed被n除的餘數是1，換個方式來說就是ed-1可以被n整除。數學表示式如下：

	ed ≡ 1 (mod φ(n))

已經e=23、φ(n)=120，接著我們進行ed ≡ 1 (mod φ(n))的化簡可得到一個二元一次方程式為等價式「eX + φ(n)Y = 1」。二元一次方程式的求解通常需要兩個運算式來代入，但我們可以知道最大公因數的定理：「給予二整數a、b，必存在有整數X、Y使得aX + bY = gcd(a,b)」。因此下面我們將進行擴展式歐幾里得演算法（Extended Euclidean Algorithm）來進行推算。

	Extended Euclidean Algorithm Strat
	23X + 120Y = 1
	--------------
	120 = 5 * 23 + 5
	 23 = 4 *  5 + 3
	  5 = 1 *  3 + 2
	  3 = 1 *  2 + 1
	--------------
	換算成餘數等式
	--------------
	120 - 5 * 23 = 5
	 23 - 4 *  5 = 3
	  5 - 1 *  3 = 2
	  3 - 1 *  2 = 1
	--------------
	逆運算
	--------------
	 1 *  3 - 1 * 2 = 1
	 1 *  3 - 1 * (5 - 1 *  3) = 1
	 1 *  3 - 1 * 5 + 1 * 3 = 1
	-1 *  5 + 2 * 3 = 1
	-1 *  5 + 2 * (23 - 4 *  5) = 1
	-1 *  5 + 2 * 23 - 8 * 5 = 1
	 2 * 23 - 9 * 5 = 1
	 2 * 23 - 9 * (120 - 5 * 23) = 1
	 2 * 23 - 9 * 120 + 45 * 23 = 1
	47 * 23 - 9 * 120 = 1
	--------------
	結論：X = 47, Y = -9
	--------------

上述例子算出一個整數解為(47, -9)，因此我們得出私鑰就是d=47。

## 公鑰與私鑰的封裝

	p = 11 （產生完馬上丟棄）
	q = 13 （產生完馬上丟棄）
	n = p * q = 143
	φ(n) = 120
	e = 23	//encode
	d = 47	//decode
	公鑰為 (n, e) = (143, 23)
	私鑰為 (n, d) = (143, 47)

## 公鑰與私鑰的驗證

假設A產生出上述的公鑰(143, 23)以及私鑰(143, 47)，透過一般純文字的方式將公鑰送給B，B取得到公鑰後，要將訊息文字"X"透過RSA演算法進行公鑰加密運算「m^e ≡ c (mod n)」。

	因為 m^e ≡ c (mod n) //message，而X的ASCII是88（10進制）
	88^23 ≡ c (mod 143)
	c = 121	//RSA加密後的文字

A收到由B送過來的資料「121」，取出自己的私鑰(143, 47)，套用RSA的解密公式進行運算「c^d ≡ m (mod n)」。

	因為 c^d ≡ m (mod n) //content
	121^47 ≡ c (mod 143)
	c = 88	//RSA解密後的文字，即為X的ASCII碼88（10進制），故證明之。